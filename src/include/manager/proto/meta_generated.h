// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_META_H_
#define FLATBUFFERS_GENERATED_META_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct ClientConnectRequest;
struct ClientConnectRequestBuilder;

struct ClientConnectReply;
struct ClientConnectReplyBuilder;

struct DBCreateRequest;
struct DBCreateRequestBuilder;

struct DBCreateReply;
struct DBCreateReplyBuilder;

struct DBgetRequest;
struct DBgetRequestBuilder;

struct DBgetReply;
struct DBgetReplyBuilder;

struct DBcontainRequest;
struct DBcontainRequestBuilder;

struct DBcontainReply;
struct DBcontainReplyBuilder;

struct DBReleaseRequest;
struct DBReleaseRequestBuilder;

struct DBReleaseReply;
struct DBReleaseReplyBuilder;

struct DBDeleteRequest;
struct DBDeleteRequestBuilder;

struct DBDeleteReply;
struct DBDeleteReplyBuilder;

struct ClientConnectRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ClientConnectRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FD = 4
  };
  int32_t fd() const {
    return GetField<int32_t>(VT_FD, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FD, 4) &&
           verifier.EndTable();
  }
};

struct ClientConnectRequestBuilder {
  typedef ClientConnectRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fd(int32_t fd) {
    fbb_.AddElement<int32_t>(ClientConnectRequest::VT_FD, fd, 0);
  }
  explicit ClientConnectRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ClientConnectRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ClientConnectRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ClientConnectRequest> CreateClientConnectRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t fd = 0) {
  ClientConnectRequestBuilder builder_(_fbb);
  builder_.add_fd(fd);
  return builder_.Finish();
}

struct ClientConnectReply FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ClientConnectReplyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CAPACITY = 4
  };
  int32_t capacity() const {
    return GetField<int32_t>(VT_CAPACITY, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CAPACITY, 4) &&
           verifier.EndTable();
  }
};

struct ClientConnectReplyBuilder {
  typedef ClientConnectReply Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_capacity(int32_t capacity) {
    fbb_.AddElement<int32_t>(ClientConnectReply::VT_CAPACITY, capacity, 0);
  }
  explicit ClientConnectReplyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ClientConnectReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ClientConnectReply>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ClientConnectReply> CreateClientConnectReply(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t capacity = 0) {
  ClientConnectReplyBuilder builder_(_fbb);
  builder_.add_capacity(capacity);
  return builder_.Finish();
}

struct DBCreateRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DBCreateRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPACE_ID = 4,
    VT_TIME_ID = 6,
    VT_VAR_ID = 8,
    VT_PATH = 10
  };
  const ::flatbuffers::String *space_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SPACE_ID);
  }
  const ::flatbuffers::String *time_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TIME_ID);
  }
  const ::flatbuffers::String *var_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VAR_ID);
  }
  const ::flatbuffers::String *path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PATH);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SPACE_ID) &&
           verifier.VerifyString(space_id()) &&
           VerifyOffset(verifier, VT_TIME_ID) &&
           verifier.VerifyString(time_id()) &&
           VerifyOffset(verifier, VT_VAR_ID) &&
           verifier.VerifyString(var_id()) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           verifier.EndTable();
  }
};

struct DBCreateRequestBuilder {
  typedef DBCreateRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_space_id(::flatbuffers::Offset<::flatbuffers::String> space_id) {
    fbb_.AddOffset(DBCreateRequest::VT_SPACE_ID, space_id);
  }
  void add_time_id(::flatbuffers::Offset<::flatbuffers::String> time_id) {
    fbb_.AddOffset(DBCreateRequest::VT_TIME_ID, time_id);
  }
  void add_var_id(::flatbuffers::Offset<::flatbuffers::String> var_id) {
    fbb_.AddOffset(DBCreateRequest::VT_VAR_ID, var_id);
  }
  void add_path(::flatbuffers::Offset<::flatbuffers::String> path) {
    fbb_.AddOffset(DBCreateRequest::VT_PATH, path);
  }
  explicit DBCreateRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DBCreateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DBCreateRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DBCreateRequest> CreateDBCreateRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> space_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> time_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> var_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> path = 0) {
  DBCreateRequestBuilder builder_(_fbb);
  builder_.add_path(path);
  builder_.add_var_id(var_id);
  builder_.add_time_id(time_id);
  builder_.add_space_id(space_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DBCreateRequest> CreateDBCreateRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *space_id = nullptr,
    const char *time_id = nullptr,
    const char *var_id = nullptr,
    const char *path = nullptr) {
  auto space_id__ = space_id ? _fbb.CreateString(space_id) : 0;
  auto time_id__ = time_id ? _fbb.CreateString(time_id) : 0;
  auto var_id__ = var_id ? _fbb.CreateString(var_id) : 0;
  auto path__ = path ? _fbb.CreateString(path) : 0;
  return CreateDBCreateRequest(
      _fbb,
      space_id__,
      time_id__,
      var_id__,
      path__);
}

struct DBCreateReply FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DBCreateReplyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STEP_COUNT = 4,
    VT_VAR_COUNT = 6,
    VT_VAR_LEN = 8,
    VT_VAR_NAME = 10
  };
  uint64_t step_count() const {
    return GetField<uint64_t>(VT_STEP_COUNT, 0);
  }
  uint64_t var_count() const {
    return GetField<uint64_t>(VT_VAR_COUNT, 0);
  }
  uint64_t var_len() const {
    return GetField<uint64_t>(VT_VAR_LEN, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *var_name() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_VAR_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_STEP_COUNT, 8) &&
           VerifyField<uint64_t>(verifier, VT_VAR_COUNT, 8) &&
           VerifyField<uint64_t>(verifier, VT_VAR_LEN, 8) &&
           VerifyOffset(verifier, VT_VAR_NAME) &&
           verifier.VerifyVector(var_name()) &&
           verifier.VerifyVectorOfStrings(var_name()) &&
           verifier.EndTable();
  }
};

struct DBCreateReplyBuilder {
  typedef DBCreateReply Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_step_count(uint64_t step_count) {
    fbb_.AddElement<uint64_t>(DBCreateReply::VT_STEP_COUNT, step_count, 0);
  }
  void add_var_count(uint64_t var_count) {
    fbb_.AddElement<uint64_t>(DBCreateReply::VT_VAR_COUNT, var_count, 0);
  }
  void add_var_len(uint64_t var_len) {
    fbb_.AddElement<uint64_t>(DBCreateReply::VT_VAR_LEN, var_len, 0);
  }
  void add_var_name(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> var_name) {
    fbb_.AddOffset(DBCreateReply::VT_VAR_NAME, var_name);
  }
  explicit DBCreateReplyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DBCreateReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DBCreateReply>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DBCreateReply> CreateDBCreateReply(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t step_count = 0,
    uint64_t var_count = 0,
    uint64_t var_len = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> var_name = 0) {
  DBCreateReplyBuilder builder_(_fbb);
  builder_.add_var_len(var_len);
  builder_.add_var_count(var_count);
  builder_.add_step_count(step_count);
  builder_.add_var_name(var_name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DBCreateReply> CreateDBCreateReplyDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t step_count = 0,
    uint64_t var_count = 0,
    uint64_t var_len = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *var_name = nullptr) {
  auto var_name__ = var_name ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*var_name) : 0;
  return CreateDBCreateReply(
      _fbb,
      step_count,
      var_count,
      var_len,
      var_name__);
}

struct DBgetRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DBgetRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPACE_ID = 4,
    VT_TIME_ID = 6,
    VT_VAR_ID = 8,
    VT_TIMEOUT = 10
  };
  const ::flatbuffers::String *space_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SPACE_ID);
  }
  const ::flatbuffers::String *time_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TIME_ID);
  }
  const ::flatbuffers::String *var_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VAR_ID);
  }
  int64_t timeout() const {
    return GetField<int64_t>(VT_TIMEOUT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SPACE_ID) &&
           verifier.VerifyString(space_id()) &&
           VerifyOffset(verifier, VT_TIME_ID) &&
           verifier.VerifyString(time_id()) &&
           VerifyOffset(verifier, VT_VAR_ID) &&
           verifier.VerifyString(var_id()) &&
           VerifyField<int64_t>(verifier, VT_TIMEOUT, 8) &&
           verifier.EndTable();
  }
};

struct DBgetRequestBuilder {
  typedef DBgetRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_space_id(::flatbuffers::Offset<::flatbuffers::String> space_id) {
    fbb_.AddOffset(DBgetRequest::VT_SPACE_ID, space_id);
  }
  void add_time_id(::flatbuffers::Offset<::flatbuffers::String> time_id) {
    fbb_.AddOffset(DBgetRequest::VT_TIME_ID, time_id);
  }
  void add_var_id(::flatbuffers::Offset<::flatbuffers::String> var_id) {
    fbb_.AddOffset(DBgetRequest::VT_VAR_ID, var_id);
  }
  void add_timeout(int64_t timeout) {
    fbb_.AddElement<int64_t>(DBgetRequest::VT_TIMEOUT, timeout, 0);
  }
  explicit DBgetRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DBgetRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DBgetRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DBgetRequest> CreateDBgetRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> space_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> time_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> var_id = 0,
    int64_t timeout = 0) {
  DBgetRequestBuilder builder_(_fbb);
  builder_.add_timeout(timeout);
  builder_.add_var_id(var_id);
  builder_.add_time_id(time_id);
  builder_.add_space_id(space_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DBgetRequest> CreateDBgetRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *space_id = nullptr,
    const char *time_id = nullptr,
    const char *var_id = nullptr,
    int64_t timeout = 0) {
  auto space_id__ = space_id ? _fbb.CreateString(space_id) : 0;
  auto time_id__ = time_id ? _fbb.CreateString(time_id) : 0;
  auto var_id__ = var_id ? _fbb.CreateString(var_id) : 0;
  return CreateDBgetRequest(
      _fbb,
      space_id__,
      time_id__,
      var_id__,
      timeout);
}

struct DBgetReply FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DBgetReplyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IP = 4,
    VT_PORT = 6
  };
  const ::flatbuffers::String *ip() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IP);
  }
  int32_t port() const {
    return GetField<int32_t>(VT_PORT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_IP) &&
           verifier.VerifyString(ip()) &&
           VerifyField<int32_t>(verifier, VT_PORT, 4) &&
           verifier.EndTable();
  }
};

struct DBgetReplyBuilder {
  typedef DBgetReply Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ip(::flatbuffers::Offset<::flatbuffers::String> ip) {
    fbb_.AddOffset(DBgetReply::VT_IP, ip);
  }
  void add_port(int32_t port) {
    fbb_.AddElement<int32_t>(DBgetReply::VT_PORT, port, 0);
  }
  explicit DBgetReplyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DBgetReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DBgetReply>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DBgetReply> CreateDBgetReply(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ip = 0,
    int32_t port = 0) {
  DBgetReplyBuilder builder_(_fbb);
  builder_.add_port(port);
  builder_.add_ip(ip);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DBgetReply> CreateDBgetReplyDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ip = nullptr,
    int32_t port = 0) {
  auto ip__ = ip ? _fbb.CreateString(ip) : 0;
  return CreateDBgetReply(
      _fbb,
      ip__,
      port);
}

struct DBcontainRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DBcontainRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPACE_ID = 4,
    VT_TIME_ID = 6,
    VT_VAR_ID = 8
  };
  const ::flatbuffers::String *space_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SPACE_ID);
  }
  const ::flatbuffers::String *time_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TIME_ID);
  }
  const ::flatbuffers::String *var_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VAR_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SPACE_ID) &&
           verifier.VerifyString(space_id()) &&
           VerifyOffset(verifier, VT_TIME_ID) &&
           verifier.VerifyString(time_id()) &&
           VerifyOffset(verifier, VT_VAR_ID) &&
           verifier.VerifyString(var_id()) &&
           verifier.EndTable();
  }
};

struct DBcontainRequestBuilder {
  typedef DBcontainRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_space_id(::flatbuffers::Offset<::flatbuffers::String> space_id) {
    fbb_.AddOffset(DBcontainRequest::VT_SPACE_ID, space_id);
  }
  void add_time_id(::flatbuffers::Offset<::flatbuffers::String> time_id) {
    fbb_.AddOffset(DBcontainRequest::VT_TIME_ID, time_id);
  }
  void add_var_id(::flatbuffers::Offset<::flatbuffers::String> var_id) {
    fbb_.AddOffset(DBcontainRequest::VT_VAR_ID, var_id);
  }
  explicit DBcontainRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DBcontainRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DBcontainRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DBcontainRequest> CreateDBcontainRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> space_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> time_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> var_id = 0) {
  DBcontainRequestBuilder builder_(_fbb);
  builder_.add_var_id(var_id);
  builder_.add_time_id(time_id);
  builder_.add_space_id(space_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DBcontainRequest> CreateDBcontainRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *space_id = nullptr,
    const char *time_id = nullptr,
    const char *var_id = nullptr) {
  auto space_id__ = space_id ? _fbb.CreateString(space_id) : 0;
  auto time_id__ = time_id ? _fbb.CreateString(time_id) : 0;
  auto var_id__ = var_id ? _fbb.CreateString(var_id) : 0;
  return CreateDBcontainRequest(
      _fbb,
      space_id__,
      time_id__,
      var_id__);
}

struct DBcontainReply FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DBcontainReplyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_CONTAIN = 4
  };
  bool is_contain() const {
    return GetField<uint8_t>(VT_IS_CONTAIN, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IS_CONTAIN, 1) &&
           verifier.EndTable();
  }
};

struct DBcontainReplyBuilder {
  typedef DBcontainReply Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_is_contain(bool is_contain) {
    fbb_.AddElement<uint8_t>(DBcontainReply::VT_IS_CONTAIN, static_cast<uint8_t>(is_contain), 0);
  }
  explicit DBcontainReplyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DBcontainReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DBcontainReply>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DBcontainReply> CreateDBcontainReply(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool is_contain = false) {
  DBcontainReplyBuilder builder_(_fbb);
  builder_.add_is_contain(is_contain);
  return builder_.Finish();
}

struct DBReleaseRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DBReleaseRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPACE_ID = 4,
    VT_TIME_ID = 6,
    VT_VAR_ID = 8
  };
  const ::flatbuffers::String *space_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SPACE_ID);
  }
  const ::flatbuffers::String *time_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TIME_ID);
  }
  const ::flatbuffers::String *var_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VAR_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SPACE_ID) &&
           verifier.VerifyString(space_id()) &&
           VerifyOffset(verifier, VT_TIME_ID) &&
           verifier.VerifyString(time_id()) &&
           VerifyOffset(verifier, VT_VAR_ID) &&
           verifier.VerifyString(var_id()) &&
           verifier.EndTable();
  }
};

struct DBReleaseRequestBuilder {
  typedef DBReleaseRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_space_id(::flatbuffers::Offset<::flatbuffers::String> space_id) {
    fbb_.AddOffset(DBReleaseRequest::VT_SPACE_ID, space_id);
  }
  void add_time_id(::flatbuffers::Offset<::flatbuffers::String> time_id) {
    fbb_.AddOffset(DBReleaseRequest::VT_TIME_ID, time_id);
  }
  void add_var_id(::flatbuffers::Offset<::flatbuffers::String> var_id) {
    fbb_.AddOffset(DBReleaseRequest::VT_VAR_ID, var_id);
  }
  explicit DBReleaseRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DBReleaseRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DBReleaseRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DBReleaseRequest> CreateDBReleaseRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> space_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> time_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> var_id = 0) {
  DBReleaseRequestBuilder builder_(_fbb);
  builder_.add_var_id(var_id);
  builder_.add_time_id(time_id);
  builder_.add_space_id(space_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DBReleaseRequest> CreateDBReleaseRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *space_id = nullptr,
    const char *time_id = nullptr,
    const char *var_id = nullptr) {
  auto space_id__ = space_id ? _fbb.CreateString(space_id) : 0;
  auto time_id__ = time_id ? _fbb.CreateString(time_id) : 0;
  auto var_id__ = var_id ? _fbb.CreateString(var_id) : 0;
  return CreateDBReleaseRequest(
      _fbb,
      space_id__,
      time_id__,
      var_id__);
}

struct DBReleaseReply FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DBReleaseReplyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_RELEASE = 4
  };
  bool is_release() const {
    return GetField<uint8_t>(VT_IS_RELEASE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IS_RELEASE, 1) &&
           verifier.EndTable();
  }
};

struct DBReleaseReplyBuilder {
  typedef DBReleaseReply Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_is_release(bool is_release) {
    fbb_.AddElement<uint8_t>(DBReleaseReply::VT_IS_RELEASE, static_cast<uint8_t>(is_release), 0);
  }
  explicit DBReleaseReplyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DBReleaseReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DBReleaseReply>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DBReleaseReply> CreateDBReleaseReply(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool is_release = false) {
  DBReleaseReplyBuilder builder_(_fbb);
  builder_.add_is_release(is_release);
  return builder_.Finish();
}

struct DBDeleteRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DBDeleteRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPACE_ID = 4,
    VT_TIME_ID = 6,
    VT_VAR_ID = 8
  };
  const ::flatbuffers::String *space_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SPACE_ID);
  }
  const ::flatbuffers::String *time_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TIME_ID);
  }
  const ::flatbuffers::String *var_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VAR_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SPACE_ID) &&
           verifier.VerifyString(space_id()) &&
           VerifyOffset(verifier, VT_TIME_ID) &&
           verifier.VerifyString(time_id()) &&
           VerifyOffset(verifier, VT_VAR_ID) &&
           verifier.VerifyString(var_id()) &&
           verifier.EndTable();
  }
};

struct DBDeleteRequestBuilder {
  typedef DBDeleteRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_space_id(::flatbuffers::Offset<::flatbuffers::String> space_id) {
    fbb_.AddOffset(DBDeleteRequest::VT_SPACE_ID, space_id);
  }
  void add_time_id(::flatbuffers::Offset<::flatbuffers::String> time_id) {
    fbb_.AddOffset(DBDeleteRequest::VT_TIME_ID, time_id);
  }
  void add_var_id(::flatbuffers::Offset<::flatbuffers::String> var_id) {
    fbb_.AddOffset(DBDeleteRequest::VT_VAR_ID, var_id);
  }
  explicit DBDeleteRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DBDeleteRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DBDeleteRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DBDeleteRequest> CreateDBDeleteRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> space_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> time_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> var_id = 0) {
  DBDeleteRequestBuilder builder_(_fbb);
  builder_.add_var_id(var_id);
  builder_.add_time_id(time_id);
  builder_.add_space_id(space_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DBDeleteRequest> CreateDBDeleteRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *space_id = nullptr,
    const char *time_id = nullptr,
    const char *var_id = nullptr) {
  auto space_id__ = space_id ? _fbb.CreateString(space_id) : 0;
  auto time_id__ = time_id ? _fbb.CreateString(time_id) : 0;
  auto var_id__ = var_id ? _fbb.CreateString(var_id) : 0;
  return CreateDBDeleteRequest(
      _fbb,
      space_id__,
      time_id__,
      var_id__);
}

struct DBDeleteReply FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DBDeleteReplyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_DELETE = 4
  };
  bool is_delete() const {
    return GetField<uint8_t>(VT_IS_DELETE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IS_DELETE, 1) &&
           verifier.EndTable();
  }
};

struct DBDeleteReplyBuilder {
  typedef DBDeleteReply Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_is_delete(bool is_delete) {
    fbb_.AddElement<uint8_t>(DBDeleteReply::VT_IS_DELETE, static_cast<uint8_t>(is_delete), 0);
  }
  explicit DBDeleteReplyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DBDeleteReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DBDeleteReply>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DBDeleteReply> CreateDBDeleteReply(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool is_delete = false) {
  DBDeleteReplyBuilder builder_(_fbb);
  builder_.add_is_delete(is_delete);
  return builder_.Finish();
}

#endif  // FLATBUFFERS_GENERATED_META_H_
