// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_METAFLB_H_
#define FLATBUFFERS_GENERATED_METAFLB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct MetaClientConnectRequest;
struct MetaClientConnectRequestBuilder;

struct MetaClientConnectReply;
struct MetaClientConnectReplyBuilder;

struct SemanticSpaceCreateRequest;
struct SemanticSpaceCreateRequestBuilder;

struct SemanticSpaceCreateReply;
struct SemanticSpaceCreateReplyBuilder;

struct StorageSpaceCreateRequest;
struct StorageSpaceCreateRequestBuilder;

struct StorageSpaceCreateReply;
struct StorageSpaceCreateReplyBuilder;

struct ContentIndexCreateRequst;
struct ContentIndexCreateRequstBuilder;

struct ContentIndexReply;
struct ContentIndexReplyBuilder;

struct ContentIndexSearchRequest;
struct ContentIndexSearchRequestBuilder;

struct ContentIndexSearchReply;
struct ContentIndexSearchReplyBuilder;

struct MetaClientConnectRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MetaClientConnectRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FD = 4
  };
  int32_t fd() const {
    return GetField<int32_t>(VT_FD, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FD, 4) &&
           verifier.EndTable();
  }
};

struct MetaClientConnectRequestBuilder {
  typedef MetaClientConnectRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fd(int32_t fd) {
    fbb_.AddElement<int32_t>(MetaClientConnectRequest::VT_FD, fd, 0);
  }
  explicit MetaClientConnectRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MetaClientConnectRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MetaClientConnectRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MetaClientConnectRequest> CreateMetaClientConnectRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t fd = 0) {
  MetaClientConnectRequestBuilder builder_(_fbb);
  builder_.add_fd(fd);
  return builder_.Finish();
}

struct MetaClientConnectReply FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MetaClientConnectReplyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WELCOME = 4
  };
  int32_t welcome() const {
    return GetField<int32_t>(VT_WELCOME, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_WELCOME, 4) &&
           verifier.EndTable();
  }
};

struct MetaClientConnectReplyBuilder {
  typedef MetaClientConnectReply Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_welcome(int32_t welcome) {
    fbb_.AddElement<int32_t>(MetaClientConnectReply::VT_WELCOME, welcome, 0);
  }
  explicit MetaClientConnectReplyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MetaClientConnectReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MetaClientConnectReply>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MetaClientConnectReply> CreateMetaClientConnectReply(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t welcome = 0) {
  MetaClientConnectReplyBuilder builder_(_fbb);
  builder_.add_welcome(welcome);
  return builder_.Finish();
}

struct SemanticSpaceCreateRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SemanticSpaceCreateRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPACE_NAME = 4,
    VT_GEO_NAMES = 6
  };
  const ::flatbuffers::String *space_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SPACE_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *geo_names() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_GEO_NAMES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SPACE_NAME) &&
           verifier.VerifyString(space_name()) &&
           VerifyOffset(verifier, VT_GEO_NAMES) &&
           verifier.VerifyVector(geo_names()) &&
           verifier.VerifyVectorOfStrings(geo_names()) &&
           verifier.EndTable();
  }
};

struct SemanticSpaceCreateRequestBuilder {
  typedef SemanticSpaceCreateRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_space_name(::flatbuffers::Offset<::flatbuffers::String> space_name) {
    fbb_.AddOffset(SemanticSpaceCreateRequest::VT_SPACE_NAME, space_name);
  }
  void add_geo_names(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> geo_names) {
    fbb_.AddOffset(SemanticSpaceCreateRequest::VT_GEO_NAMES, geo_names);
  }
  explicit SemanticSpaceCreateRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SemanticSpaceCreateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SemanticSpaceCreateRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SemanticSpaceCreateRequest> CreateSemanticSpaceCreateRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> space_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> geo_names = 0) {
  SemanticSpaceCreateRequestBuilder builder_(_fbb);
  builder_.add_geo_names(geo_names);
  builder_.add_space_name(space_name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SemanticSpaceCreateRequest> CreateSemanticSpaceCreateRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *space_name = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *geo_names = nullptr) {
  auto space_name__ = space_name ? _fbb.CreateString(space_name) : 0;
  auto geo_names__ = geo_names ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*geo_names) : 0;
  return CreateSemanticSpaceCreateRequest(
      _fbb,
      space_name__,
      geo_names__);
}

struct SemanticSpaceCreateReply FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SemanticSpaceCreateReplyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPACE_ID = 4
  };
  const ::flatbuffers::String *space_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SPACE_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SPACE_ID) &&
           verifier.VerifyString(space_id()) &&
           verifier.EndTable();
  }
};

struct SemanticSpaceCreateReplyBuilder {
  typedef SemanticSpaceCreateReply Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_space_id(::flatbuffers::Offset<::flatbuffers::String> space_id) {
    fbb_.AddOffset(SemanticSpaceCreateReply::VT_SPACE_ID, space_id);
  }
  explicit SemanticSpaceCreateReplyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SemanticSpaceCreateReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SemanticSpaceCreateReply>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SemanticSpaceCreateReply> CreateSemanticSpaceCreateReply(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> space_id = 0) {
  SemanticSpaceCreateReplyBuilder builder_(_fbb);
  builder_.add_space_id(space_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SemanticSpaceCreateReply> CreateSemanticSpaceCreateReplyDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *space_id = nullptr) {
  auto space_id__ = space_id ? _fbb.CreateString(space_id) : 0;
  return CreateSemanticSpaceCreateReply(
      _fbb,
      space_id__);
}

struct StorageSpaceCreateRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StorageSpaceCreateRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPACE_NAME = 4,
    VT_WRITABLE = 6,
    VT_KIND = 8,
    VT_SPACE_SIZE = 10,
    VT_SPACE_ID = 12,
    VT_USER_NAME = 14,
    VT_CONF_FILE = 16,
    VT_POOL_NAME = 18,
    VT_ROOT_PATH = 20
  };
  const ::flatbuffers::String *space_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SPACE_NAME);
  }
  bool writable() const {
    return GetField<uint8_t>(VT_WRITABLE, 0) != 0;
  }
  const ::flatbuffers::String *kind() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KIND);
  }
  uint64_t space_size() const {
    return GetField<uint64_t>(VT_SPACE_SIZE, 0);
  }
  const ::flatbuffers::String *space_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SPACE_ID);
  }
  const ::flatbuffers::String *user_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USER_NAME);
  }
  const ::flatbuffers::String *conf_file() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONF_FILE);
  }
  const ::flatbuffers::String *pool_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_POOL_NAME);
  }
  const ::flatbuffers::String *root_path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ROOT_PATH);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SPACE_NAME) &&
           verifier.VerifyString(space_name()) &&
           VerifyField<uint8_t>(verifier, VT_WRITABLE, 1) &&
           VerifyOffset(verifier, VT_KIND) &&
           verifier.VerifyString(kind()) &&
           VerifyField<uint64_t>(verifier, VT_SPACE_SIZE, 8) &&
           VerifyOffset(verifier, VT_SPACE_ID) &&
           verifier.VerifyString(space_id()) &&
           VerifyOffset(verifier, VT_USER_NAME) &&
           verifier.VerifyString(user_name()) &&
           VerifyOffset(verifier, VT_CONF_FILE) &&
           verifier.VerifyString(conf_file()) &&
           VerifyOffset(verifier, VT_POOL_NAME) &&
           verifier.VerifyString(pool_name()) &&
           VerifyOffset(verifier, VT_ROOT_PATH) &&
           verifier.VerifyString(root_path()) &&
           verifier.EndTable();
  }
};

struct StorageSpaceCreateRequestBuilder {
  typedef StorageSpaceCreateRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_space_name(::flatbuffers::Offset<::flatbuffers::String> space_name) {
    fbb_.AddOffset(StorageSpaceCreateRequest::VT_SPACE_NAME, space_name);
  }
  void add_writable(bool writable) {
    fbb_.AddElement<uint8_t>(StorageSpaceCreateRequest::VT_WRITABLE, static_cast<uint8_t>(writable), 0);
  }
  void add_kind(::flatbuffers::Offset<::flatbuffers::String> kind) {
    fbb_.AddOffset(StorageSpaceCreateRequest::VT_KIND, kind);
  }
  void add_space_size(uint64_t space_size) {
    fbb_.AddElement<uint64_t>(StorageSpaceCreateRequest::VT_SPACE_SIZE, space_size, 0);
  }
  void add_space_id(::flatbuffers::Offset<::flatbuffers::String> space_id) {
    fbb_.AddOffset(StorageSpaceCreateRequest::VT_SPACE_ID, space_id);
  }
  void add_user_name(::flatbuffers::Offset<::flatbuffers::String> user_name) {
    fbb_.AddOffset(StorageSpaceCreateRequest::VT_USER_NAME, user_name);
  }
  void add_conf_file(::flatbuffers::Offset<::flatbuffers::String> conf_file) {
    fbb_.AddOffset(StorageSpaceCreateRequest::VT_CONF_FILE, conf_file);
  }
  void add_pool_name(::flatbuffers::Offset<::flatbuffers::String> pool_name) {
    fbb_.AddOffset(StorageSpaceCreateRequest::VT_POOL_NAME, pool_name);
  }
  void add_root_path(::flatbuffers::Offset<::flatbuffers::String> root_path) {
    fbb_.AddOffset(StorageSpaceCreateRequest::VT_ROOT_PATH, root_path);
  }
  explicit StorageSpaceCreateRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StorageSpaceCreateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StorageSpaceCreateRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StorageSpaceCreateRequest> CreateStorageSpaceCreateRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> space_name = 0,
    bool writable = false,
    ::flatbuffers::Offset<::flatbuffers::String> kind = 0,
    uint64_t space_size = 0,
    ::flatbuffers::Offset<::flatbuffers::String> space_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> user_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> conf_file = 0,
    ::flatbuffers::Offset<::flatbuffers::String> pool_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> root_path = 0) {
  StorageSpaceCreateRequestBuilder builder_(_fbb);
  builder_.add_space_size(space_size);
  builder_.add_root_path(root_path);
  builder_.add_pool_name(pool_name);
  builder_.add_conf_file(conf_file);
  builder_.add_user_name(user_name);
  builder_.add_space_id(space_id);
  builder_.add_kind(kind);
  builder_.add_space_name(space_name);
  builder_.add_writable(writable);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StorageSpaceCreateRequest> CreateStorageSpaceCreateRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *space_name = nullptr,
    bool writable = false,
    const char *kind = nullptr,
    uint64_t space_size = 0,
    const char *space_id = nullptr,
    const char *user_name = nullptr,
    const char *conf_file = nullptr,
    const char *pool_name = nullptr,
    const char *root_path = nullptr) {
  auto space_name__ = space_name ? _fbb.CreateString(space_name) : 0;
  auto kind__ = kind ? _fbb.CreateString(kind) : 0;
  auto space_id__ = space_id ? _fbb.CreateString(space_id) : 0;
  auto user_name__ = user_name ? _fbb.CreateString(user_name) : 0;
  auto conf_file__ = conf_file ? _fbb.CreateString(conf_file) : 0;
  auto pool_name__ = pool_name ? _fbb.CreateString(pool_name) : 0;
  auto root_path__ = root_path ? _fbb.CreateString(root_path) : 0;
  return CreateStorageSpaceCreateRequest(
      _fbb,
      space_name__,
      writable,
      kind__,
      space_size,
      space_id__,
      user_name__,
      conf_file__,
      pool_name__,
      root_path__);
}

struct StorageSpaceCreateReply FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StorageSpaceCreateReplyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STORAGE_ID = 4
  };
  const ::flatbuffers::String *storage_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STORAGE_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STORAGE_ID) &&
           verifier.VerifyString(storage_id()) &&
           verifier.EndTable();
  }
};

struct StorageSpaceCreateReplyBuilder {
  typedef StorageSpaceCreateReply Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_storage_id(::flatbuffers::Offset<::flatbuffers::String> storage_id) {
    fbb_.AddOffset(StorageSpaceCreateReply::VT_STORAGE_ID, storage_id);
  }
  explicit StorageSpaceCreateReplyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StorageSpaceCreateReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StorageSpaceCreateReply>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StorageSpaceCreateReply> CreateStorageSpaceCreateReply(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> storage_id = 0) {
  StorageSpaceCreateReplyBuilder builder_(_fbb);
  builder_.add_storage_id(storage_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StorageSpaceCreateReply> CreateStorageSpaceCreateReplyDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *storage_id = nullptr) {
  auto storage_id__ = storage_id ? _fbb.CreateString(storage_id) : 0;
  return CreateStorageSpaceCreateReply(
      _fbb,
      storage_id__);
}

struct ContentIndexCreateRequst FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ContentIndexCreateRequstBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEMANTIC_SPACE_NAME = 4,
    VT_STORAGE_SPACE_NAME = 6,
    VT_DIR_PATH = 8
  };
  const ::flatbuffers::String *semantic_space_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SEMANTIC_SPACE_NAME);
  }
  const ::flatbuffers::String *storage_space_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STORAGE_SPACE_NAME);
  }
  const ::flatbuffers::String *dir_path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DIR_PATH);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SEMANTIC_SPACE_NAME) &&
           verifier.VerifyString(semantic_space_name()) &&
           VerifyOffset(verifier, VT_STORAGE_SPACE_NAME) &&
           verifier.VerifyString(storage_space_name()) &&
           VerifyOffset(verifier, VT_DIR_PATH) &&
           verifier.VerifyString(dir_path()) &&
           verifier.EndTable();
  }
};

struct ContentIndexCreateRequstBuilder {
  typedef ContentIndexCreateRequst Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_semantic_space_name(::flatbuffers::Offset<::flatbuffers::String> semantic_space_name) {
    fbb_.AddOffset(ContentIndexCreateRequst::VT_SEMANTIC_SPACE_NAME, semantic_space_name);
  }
  void add_storage_space_name(::flatbuffers::Offset<::flatbuffers::String> storage_space_name) {
    fbb_.AddOffset(ContentIndexCreateRequst::VT_STORAGE_SPACE_NAME, storage_space_name);
  }
  void add_dir_path(::flatbuffers::Offset<::flatbuffers::String> dir_path) {
    fbb_.AddOffset(ContentIndexCreateRequst::VT_DIR_PATH, dir_path);
  }
  explicit ContentIndexCreateRequstBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ContentIndexCreateRequst> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ContentIndexCreateRequst>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ContentIndexCreateRequst> CreateContentIndexCreateRequst(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> semantic_space_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> storage_space_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dir_path = 0) {
  ContentIndexCreateRequstBuilder builder_(_fbb);
  builder_.add_dir_path(dir_path);
  builder_.add_storage_space_name(storage_space_name);
  builder_.add_semantic_space_name(semantic_space_name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ContentIndexCreateRequst> CreateContentIndexCreateRequstDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *semantic_space_name = nullptr,
    const char *storage_space_name = nullptr,
    const char *dir_path = nullptr) {
  auto semantic_space_name__ = semantic_space_name ? _fbb.CreateString(semantic_space_name) : 0;
  auto storage_space_name__ = storage_space_name ? _fbb.CreateString(storage_space_name) : 0;
  auto dir_path__ = dir_path ? _fbb.CreateString(dir_path) : 0;
  return CreateContentIndexCreateRequst(
      _fbb,
      semantic_space_name__,
      storage_space_name__,
      dir_path__);
}

struct ContentIndexReply FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ContentIndexReplyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WELCOME = 4
  };
  int32_t welcome() const {
    return GetField<int32_t>(VT_WELCOME, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_WELCOME, 4) &&
           verifier.EndTable();
  }
};

struct ContentIndexReplyBuilder {
  typedef ContentIndexReply Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_welcome(int32_t welcome) {
    fbb_.AddElement<int32_t>(ContentIndexReply::VT_WELCOME, welcome, 0);
  }
  explicit ContentIndexReplyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ContentIndexReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ContentIndexReply>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ContentIndexReply> CreateContentIndexReply(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t welcome = 0) {
  ContentIndexReplyBuilder builder_(_fbb);
  builder_.add_welcome(welcome);
  return builder_.Finish();
}

struct ContentIndexSearchRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ContentIndexSearchRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GEO_NAMES = 4,
    VT_TIMES = 6,
    VT_VAR_NAMES = 8,
    VT_GROUP_NAME = 10
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *geo_names() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_GEO_NAMES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *times() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TIMES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *var_names() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_VAR_NAMES);
  }
  const ::flatbuffers::String *group_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GROUP_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GEO_NAMES) &&
           verifier.VerifyVector(geo_names()) &&
           verifier.VerifyVectorOfStrings(geo_names()) &&
           VerifyOffset(verifier, VT_TIMES) &&
           verifier.VerifyVector(times()) &&
           verifier.VerifyVectorOfStrings(times()) &&
           VerifyOffset(verifier, VT_VAR_NAMES) &&
           verifier.VerifyVector(var_names()) &&
           verifier.VerifyVectorOfStrings(var_names()) &&
           VerifyOffset(verifier, VT_GROUP_NAME) &&
           verifier.VerifyString(group_name()) &&
           verifier.EndTable();
  }
};

struct ContentIndexSearchRequestBuilder {
  typedef ContentIndexSearchRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_geo_names(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> geo_names) {
    fbb_.AddOffset(ContentIndexSearchRequest::VT_GEO_NAMES, geo_names);
  }
  void add_times(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> times) {
    fbb_.AddOffset(ContentIndexSearchRequest::VT_TIMES, times);
  }
  void add_var_names(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> var_names) {
    fbb_.AddOffset(ContentIndexSearchRequest::VT_VAR_NAMES, var_names);
  }
  void add_group_name(::flatbuffers::Offset<::flatbuffers::String> group_name) {
    fbb_.AddOffset(ContentIndexSearchRequest::VT_GROUP_NAME, group_name);
  }
  explicit ContentIndexSearchRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ContentIndexSearchRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ContentIndexSearchRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ContentIndexSearchRequest> CreateContentIndexSearchRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> geo_names = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> times = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> var_names = 0,
    ::flatbuffers::Offset<::flatbuffers::String> group_name = 0) {
  ContentIndexSearchRequestBuilder builder_(_fbb);
  builder_.add_group_name(group_name);
  builder_.add_var_names(var_names);
  builder_.add_times(times);
  builder_.add_geo_names(geo_names);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ContentIndexSearchRequest> CreateContentIndexSearchRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *geo_names = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *times = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *var_names = nullptr,
    const char *group_name = nullptr) {
  auto geo_names__ = geo_names ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*geo_names) : 0;
  auto times__ = times ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*times) : 0;
  auto var_names__ = var_names ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*var_names) : 0;
  auto group_name__ = group_name ? _fbb.CreateString(group_name) : 0;
  return CreateContentIndexSearchRequest(
      _fbb,
      geo_names__,
      times__,
      var_names__,
      group_name__);
}

struct ContentIndexSearchReply FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ContentIndexSearchReplyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPACE_ID = 4,
    VT_TIME_ID = 6,
    VT_VAR_ID = 8
  };
  const ::flatbuffers::String *space_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SPACE_ID);
  }
  const ::flatbuffers::String *time_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TIME_ID);
  }
  const ::flatbuffers::String *var_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VAR_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SPACE_ID) &&
           verifier.VerifyString(space_id()) &&
           VerifyOffset(verifier, VT_TIME_ID) &&
           verifier.VerifyString(time_id()) &&
           VerifyOffset(verifier, VT_VAR_ID) &&
           verifier.VerifyString(var_id()) &&
           verifier.EndTable();
  }
};

struct ContentIndexSearchReplyBuilder {
  typedef ContentIndexSearchReply Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_space_id(::flatbuffers::Offset<::flatbuffers::String> space_id) {
    fbb_.AddOffset(ContentIndexSearchReply::VT_SPACE_ID, space_id);
  }
  void add_time_id(::flatbuffers::Offset<::flatbuffers::String> time_id) {
    fbb_.AddOffset(ContentIndexSearchReply::VT_TIME_ID, time_id);
  }
  void add_var_id(::flatbuffers::Offset<::flatbuffers::String> var_id) {
    fbb_.AddOffset(ContentIndexSearchReply::VT_VAR_ID, var_id);
  }
  explicit ContentIndexSearchReplyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ContentIndexSearchReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ContentIndexSearchReply>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ContentIndexSearchReply> CreateContentIndexSearchReply(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> space_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> time_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> var_id = 0) {
  ContentIndexSearchReplyBuilder builder_(_fbb);
  builder_.add_var_id(var_id);
  builder_.add_time_id(time_id);
  builder_.add_space_id(space_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ContentIndexSearchReply> CreateContentIndexSearchReplyDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *space_id = nullptr,
    const char *time_id = nullptr,
    const char *var_id = nullptr) {
  auto space_id__ = space_id ? _fbb.CreateString(space_id) : 0;
  auto time_id__ = time_id ? _fbb.CreateString(time_id) : 0;
  auto var_id__ = var_id ? _fbb.CreateString(var_id) : 0;
  return CreateContentIndexSearchReply(
      _fbb,
      space_id__,
      time_id__,
      var_id__);
}

#endif  // FLATBUFFERS_GENERATED_METAFLB_H_
